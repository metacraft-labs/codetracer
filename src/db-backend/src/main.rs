#![allow(clippy::enum_variant_names)]
#![allow(clippy::new_without_default)]
#![deny(clippy::panic)]
#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![deny(clippy::exit)]
#![allow(dead_code)]

// TODO: deny when we cleanup
// dead code usage/add only
// specific allows
// #![deny(dead_code)]
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use std::sync::{mpsc, LazyLock, Mutex};
use std::thread;
use std::time::Instant;
use std::{error::Error, panic};

use clap::Parser;
use log::{error, info};
use task::{EventId, EventKind, Notification, NotificationKind};

mod calltrace;
mod core;
mod db;
mod distinct_vec;
mod event_db;
mod expr_loader;
mod flow_preloader;
mod handler;
mod lang;
mod program_search_tool;
mod receiver;
mod response;
mod sender;
mod step_lines_loader;
mod task;
mod trace_processor;
mod tracepoint_interpreter;
mod value;

use core::Core;
use db::Db;
use handler::Handler;
use receiver::{handle_task, Receiver};
use response::Response;
use task::Task;
use sender::Sender;
use trace_processor::{load_trace_data, load_trace_metadata, TraceProcessor};

/// a custom backend for ruby (maybe others) support
/// based on db-like approach based on trace instead of rr/gdb
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct Args {
    /// codetracer unique run instance id
    caller_process_pid: usize,

    /// path to trace file generated by record
    trace_file: PathBuf,

    /// path to trace metadata file generated by record
    trace_metadata_file: PathBuf,
}

static TX2: LazyLock<Mutex<Option<mpsc::Sender<Response>>>> = LazyLock::new(|| Mutex::new(None)); // ðŸ¤®

fn main() -> Result<(), Box<dyn Error>> {
    let cli = Args::parse();
    let core = Core {
        socket: None,
        caller_process_pid: cli.caller_process_pid,
    };

    let run_dir = core.run_dir();
    fs::create_dir_all(&run_dir)?;
    let log_path = run_dir.join("db-backend_db-backend_0.log");
    eprintln!("{}", log_path.display());

    let mut builder = env_logger::Builder::from_default_env();
    // credit to https://github.com/rust-cli/env_logger/issues/125#issuecomment-1406333500
    // and https://github.com/rust-cli/env_logger/issues/125#issuecomment-1582209797
    // for file targetting code
    #[allow(clippy::expect_used)]
    let target = Box::new(fs::File::create(log_path).expect("Can't create file"));

    builder
        .target(env_logger::Target::Pipe(target))
        .format(|buf, record| {
            writeln!(
                buf,
                "{} - {}:{} {}",
                record.level(),
                record.file().unwrap_or("<unknown>"),
                record.line().unwrap_or(0),
                record.args()
            )
        })
        .filter(None, log::LevelFilter::Info)
        .init();

    // duration code copied from
    // https://rust-lang-nursery.github.io/rust-cookbook/datetime/duration.html

    // loading trace and metadata
    let start = Instant::now();
    let trace = load_trace_data(&cli.trace_file)?;
    let trace_metadata = load_trace_metadata(&cli.trace_metadata_file)?;
    let duration = start.elapsed();
    info!("loading trace: duration: {:?}", duration);

    // post processing
    let start2 = Instant::now();
    let mut db = Db::new(&trace_metadata.workdir);
    let mut trace_processor = TraceProcessor::new(&mut db);
    trace_processor.postprocess(&trace)?;
    let duration2 = start2.elapsed();
    info!("postprocessing trace: duration: {:?}", duration2);
    // info!("{:#?}", &db.variables);
    // info!("cell_changes {:#?}", db.cell_changes);
    // db.display_variable_cells();

    let mut receiver = Receiver::new();

    let mut sender = Sender::new();
    let (tx, rx): (mpsc::Sender<Response>, mpsc::Receiver<Response>) = mpsc::channel();
    let (task_tx, task_rx) = mpsc::channel::<Task>();

    // No other threads will be using the mutex, so .lock() will never return Err()
    #[allow(clippy::unwrap_used)]
    {
        let mut guard = TX2.lock().unwrap();
        *guard = Some(tx.clone());
    }

    thread::spawn(move || {
        // TODO: eventually create like that
        // so socket is always valid and not Option
        // to remove usage of `unwrap` in Core
        // let mut sender = Sender::setup(..);

        // Already panicking so the unwraps won't change anything
        #[allow(clippy::unwrap_used)]
        panic::set_hook(Box::new(|info| {
            error!("PANIC!!! {}", info);

            let guard = TX2.lock().unwrap();
            let channel = guard.clone().unwrap();

            let msg = format!("DB backend crashed! Please report this. Message: \"{}\"", info);

            let notification = Notification::new(NotificationKind::Error, &msg, false);

            channel
                .send(Response::EventResponse((
                    EventKind::NewNotification,
                    EventId::new("backend-crash-0"),
                    serde_json::to_string(&notification).unwrap(),
                    false,
                )))
                .unwrap();
        }));

        // backend-specific handler for
        //   each different task
        let mut handler = Handler::new(Box::new(db), tx.clone());

        let core_for_handler = Core {
            socket: None,
            caller_process_pid: cli.caller_process_pid,
        };

        let receiver_thread = std::thread::spawn(move || {
            let _setup_res = receiver.setup(cli.caller_process_pid);
            if let Err(e) = receiver.receive_loop(task_tx) {
                error!("receiver thread error: {:?}", e);
            }
        });

        for task in task_rx {
            let res = handle_task(&core_for_handler, &mut handler, task);
            if let Err(handle_error) = res {
                error!("backend: handle error: {:?}", handle_error);
            } else if handler.indirect_send {
                let responses = handler.get_responses_for_sending_and_clear();
                let mut sender = Sender::new();
                let _ = sender.setup(core_for_handler.caller_process_pid, false);
                for response in responses {
                    if let Err(e) = sender.send_response(response) {
                        error!("sender couldn't send message: {:?}", e);
                    }
                }
            }
        }

        let _ = receiver_thread.join();
    });

    sender.setup(cli.caller_process_pid, true)?;
    sender.send_loop(rx)?;

    Ok(())
}
