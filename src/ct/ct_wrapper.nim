import
  std / [os, osproc, strformat, strtabs, posix],
  json_serialization, json_serialization / std / tables

type
  PathsConfig = Table[string, string]

    # PATH: string
    # LD_LIBRARY_PATH: string
    # PYTHONPATH: string

const
  pathsConfigFile = "ct_paths.json"
  missingConfigHint = "Try setting CODETRACER_CT_PATHS explicitly or run `direnv allow` inside the codetracer source folder."

proc searchForConfig(startDirs: seq[string]): tuple[path: string, attempts: seq[string]] =
  ## Walk each directory in `startDirs` upwards until the filesystem root
  ## looking for `ct_paths.json`. Returns the first hit as well as the list
  ## of paths that were examined.
  var attempts: seq[string] = @[]

  for dir in startDirs:
    if dir.len == 0:
      continue

    var cursor: string
    try:
      cursor = dir.absolutePath()
    except OSError:
      continue

    while true:
      let candidate = cursor / pathsConfigFile
      if candidate notin attempts:
        attempts.add(candidate)
        if fileExists(candidate):
          return (candidate, attempts)

      let parent = cursor.parentDir
      if parent.len == 0 or parent == cursor:
        break
      cursor = parent

  return ("", attempts)

proc locatePathsConfig(): string =
  ## Resolve the location of `ct_paths.json`. Honour an explicit
  ## CODETRACER_CT_PATHS override first; otherwise search upwards from
  ## both the executable's directory and the current working directory.
  let envCandidate = getEnv("CODETRACER_CT_PATHS")
  if envCandidate.len > 0:
    if fileExists(envCandidate):
      return envCandidate
    raise newException(IOError,
      fmt"CODETRACER_CT_PATHS points at '{envCandidate}', but the file does not exist.")

  var searchRoots: seq[string] = @[]
  let appDir = getAppDir()
  if appDir.len > 0:
    searchRoots.add(appDir)

  try:
    let currentDir = getCurrentDir()
    if currentDir.len > 0 and currentDir notin searchRoots:
      searchRoots.add(currentDir)
  except OSError:
    discard

  let (discovered, attempts) = searchForConfig(searchRoots)
  if discovered.len > 0:
    return discovered

  var message = "expected a paths config generated by shell.nix, but could not find ct_paths.json.\n"
  if attempts.len > 0:
    message.add("Looked in:\n")
    for candidate in attempts:
      message.add("  " & candidate & "\n")
  message.add(missingConfigHint)
  raise newException(IOError, message)

var ctProcess: Process = nil

proc start(args: seq[string]) =
  var configPath = ""
  try:
    configPath = locatePathsConfig()
    var config = Json.decode(readFile(configPath), PathsConfig)
    var env = newStringTable(modeStyleInsensitive)
    for name, value in envPairs():
      env[name] = value

    for name, ct_value in config:
      if name in env:
        env[name] = fmt"{ct_value}:{env[name]}"
      else:
        env[name] = ct_value
      # echo name, " ", ct_value, " ", env[name]

    # needed by `ct record` when called by the interactive recording form
    # and index.nim, so it can use the correct pid (index.nim sees the pid
    # of the process of ct_wrapper in the tup/dev build)
    let codetracerWrapperPid = getCurrentProcessId()
    env["CODETRACER_WRAPPER_PID"] = $codetracerWrapperPid

    # don't debug/log with echo: breaks ct trace_metadata json output
    # writeFile("ct_wrapper.log", "CT WRAPPER: putting pid " & $codetracerWrapperPid)

    ctProcess = startProcess(
      getAppDir() / "codetracer_depending_on_env_vars_in_tup",
      # workingDir = getAppDir().parentDir.parentDir, # repo folder
      args = args,
      env = env,
      options = {poParentStreams, poStdErrToStdOut})
    quit(waitForExit(ctProcess))
  except:
    echo "ct helper error: ", getCurrentExceptionMsg()
    if configPath.len > 0:
      echo "  ct paths config path: ", configPath
    quit(1)

onSignal(SIGTERM):
  if not ctProcess.isNil:
    discard kill(ctProcess.processID().cint, SIGTERM)
    quit(128 + SIGTERM)

onSignal(SIGINT):
  if not ctProcess.isNil:
    discard kill(ctProcess.processID().cint, SIGINT)
    quit(128 + SIGINT)

start(commandLineParams())
