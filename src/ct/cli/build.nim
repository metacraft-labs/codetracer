import
  std / [os, osproc, strformat, strtabs, sequtils],
  json_serialization, json_serialization / std / tables
import ../../common/config

type
  PathsConfig = Table[string, string]

proc setup_env*(configPath: string): StringTableRef =
  if not existsFile(configPath):
      echo fmt"error: expected a paths config generated by shell.nix in {configPath}:"
      echo "  please try to go in the codetracer source folder and run `direnv allow` there"
      quit(1)
  var config = Json.decode(readFile(configPath), PathsConfig)
  var env = newStringTable(modeStyleInsensitive)
  for name, value in envPairs():
    env[name] = value

  for name, ct_value in config:
    if name in env:
      env[name] = fmt"{ct_value}:{env[name]}"
    else:
      env[name] = ct_value
  result = env


proc build*(program_path: string, output_path: string) =
  let ct_config = loadConfig(folder=getCurrentDir(), inTest=false)
  if ct_config.rrBackendEnabled:
    let configPath = ct_config.rrBackendCtPaths

    try:
      var env = setup_env(configPath)
      let args = @["build", program_path, output_path]
      let p = startProcess(
        ct_config.rrBackendPath,
        args = args,
        env = env,
        options = {poParentStreams, poStdErrToStdOut})
      quit(waitForExit(p))
    except:
      echo "ct helper error: ", getCurrentExceptionMsg()
      echo "  ct paths config path: ", configPath
      quit(1)
  else:
    echo "This functionality requires a codetracer-rr-backend installation"
