import
  std / [os, osproc, strformat, strtabs],
  json_serialization, json_serialization / std / tables
import ../../common/config

type
  PathsConfig = Table[string, string]

proc setupEnv*(configPath: string): StringTableRef =
  if not fileExists(configPath):
      echo fmt"error: expected a paths config generated by shell.nix in {configPath}:"
      echo "  please try to go in the codetracer source folder and run `direnv allow` there"
      quit(1)
  var config = Json.decode(readFile(configPath), PathsConfig)
  var env = newStringTable(modeStyleInsensitive)
  for name, value in envPairs():
    env[name] = value

  for name, ctValue in config:
    if name in env:
      env[name] = fmt"{ctValue}:{env[name]}"
    else:
      env[name] = ctValue
  result = env


proc build*(programPath: string, outputPath: string) =
  let ctConfig = loadConfig(folder=getCurrentDir(), inTest=false)
  if ctConfig.rrBackend.enabled:
    let configPath = ctConfig.rrBackend.ctPaths

    try:
      var env = setupEnv(configPath)
      let args = @["build", programPath, outputPath]
      let p = startProcess(
        ctConfig.rrBackend.path,
        args = args,
        env = env,
        options = {poParentStreams, poStdErrToStdOut})
      quit(waitForExit(p))
    except:
      echo "ct helper error: ", getCurrentExceptionMsg()
      echo "  ct paths config path: ", configPath
      quit(1)
  else:
    echo "This functionality requires a codetracer-rr-backend installation"
