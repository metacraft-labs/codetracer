# Codebase insights
- Ruby loops were originally detected only for 'while' and 'until'.
- 'each' loops can be recognized by handling 'call' nodes with a block whose method name is 'each'.
- Added a regression test ensuring `ExprLoader` detects Ruby `each` loops correctly.
- The `tui` crate contains a sample trace under `src/tui/trace/` used for basic testing.
- The Debug Adapter Protocol client communicates over a Unix domain socket using the same framing protocol, implemented in `src/tui/src/dap_client.rs`.
- Added initial SetBreakpoints handling in db-backend DAP server.
- When using the DAP stdio transport, all diagnostic output must go to stderr
  to avoid corrupting the message stream.
- `DapParser` now buffers data via `add_bytes` and exposes parsed payloads with
  `get_message()`, so callers need to drain messages until `None` after feeding
  new bytes.
- The db-backend DAP server now responds to the `configurationDone` request.

- Electron lifecycle: the backend-manager process is spawned in
  `src/frontend/index.nim` during `ready()`. Previously, it was only stopped
  via an explicit UI action. We now centralize cleanup with `stopBackendManager()`
  and hook it to `app.on('before-quit')`, `app.on('window-all-closed')`, and
  Node process signals (`SIGINT`, `SIGTERM`, `SIGHUP`) to ensure the process
  is always terminated when the app exits.
- `ct record` now prefers `CODETRACER_PYTHON_INTERPRETER`, `PYTHON_EXECUTABLE`, `PYTHONEXECUTABLE`, or PATH resolution to locate the Python runtime before delegating to the db backend, and `db-backend-record` expects the resolved interpreter via `--python-interpreter` when launching the recorder.
- `ct record` resolves Python via env vars (`CODETRACER_PYTHON_INTERPRETER`, `PYTHON_EXECUTABLE`, `PYTHONEXECUTABLE`, `PYTHON`) before checking PATH. When falling back to PATH we now call `findExe(..., followSymlinks=false)` so virtualenv launchers keep their original location and `pyvenv.cfg` remains discoverable.
- Interpreter overrides (e.g. `CODETRACER_PYTHON_INTERPRETER`) are now treated as authoritative; if the configured path cannot be resolved we error instead of silently falling back to PATH.
- `ct record` verifies that `codetracer_python_recorder` is importable before launching the db backend and prints actionable guidance if the module is missing or broken.
- Sudoku test-program datasets include intentionally invalid boards (e.g., examples #3 and #6) with duplicate digits inside a sub-grid; solvers should detect and report these gracefully.
- `appimage-scripts/build_appimage.sh` assumes a devshell: it invokes `nix build`/`nix eval` directly and runs `npm install`/`npx yarn`, so it needs host network access and the git worktree metadata that a pure derivation build lacks.
- `appimage-scripts/build_appimage2.sh` now consumes `packages.${system}.appimagePayload`, which layers the Rust binaries atop the dependency tree from `appimageDeps`; both derivations pre-run `patchelf`, so the script only patches the locally built Nim binaries and bundled Ruby while everything else already targets `/lib64/ld-linuxâ€¦` (or `/lib/ld-linux-aarch64.so.1`) with `\$ORIGIN/../lib` rpaths. The Nim outputs are provided via dedicated derivations (`appimageCtUnwrapped`, `appimageDbBackendRecord`, etc.) so we can pinpoint issues per artifact.
- `flake.nix` sets `self.submodules = true`, so `nix build` automatically materializes the git submodules under `libs/`, which is required for the Nim derivations to see their dependencies.
- Stylus-based frontend stylesheets now come from the `packages.${system}.appimageCss` derivation; `build_css.sh` simply copies that output, and `appimagePayload` pulls the same artifacts, so the AppDir no longer depends on ad-hoc `node_modules` during assembly.
- `appimagePayload` now stages the launch scripts (`bin/ct`, `bin/ruby`, `AppRun`), config/resources, and the Ruby recorder submodule directly; `build_appimage2.sh` just handles impure steps (installing Ruby/Electron, copying `node_modules`, updating `frontend_bundle.js`, and calling `appimagetool`).
- Third-party frontend assets that were previously symlinks into `node_modules` (`@exuanbo`, `golden-layout/dist`, `monaco-editor/min`, `mousetrap`, `vex-js`, `xterm`) are now materialized from `node-modules-derivation` inside `appimagePayload`, preventing broken symlinks when the payload is copied out of the Nix store.
- Ruby 3.3 comes from `appimageDeps` (via `pkgs.ruby_3_3`) and is patched inside the derivation, so the AppDir no longer copies Ruby from the devshell during the AppImage build.
- `nix/packages/default.nix` now hides helper bindings like `mkNimBinary` via `builtins.removeAttrs` so `perSystem.packages` exposes only real derivations; flake checks will reject non-package values there.
